# javascript 학습 준비
1. vs code
2. Node.js
  - 서버 프로그램 개발을 자바스크립트로 가능하도록 하는 자바스크립트 런타임 환경
  - 자바스크립트는 브라우저에서 동작하는 언어인데, java를 intellij에서 실행하는 것처럼 개발환경을 구성하기 위한 것이다. 그래서 크롬 개발자 도구에서 console.log를 사용했다.
  - 크롬에서 nodejs 검색
  - 설치 -> automatically install 옵션 체크
  - poershell에서 엔터
  - vscode 재실행
  - 터미널에서 node -v에서 버전 뜨면 완료
  - cmd 창에서 npm -v

## vs code extension 설치
1. javascript(ES6) code snippets
2. ESLint
  - ES + Lint로 ES는 ECMA Script, Lint는 소스 코드를 분석하여 프로그램 오류, 버그, 스타일 오류, 의심스러운 구조체의 표시를 달아놓는 것으로, JS 문법 오류를 체크해준다.

# JavaScript 기본 문법
ch01_js_basic
01_js_location.html

## 자바스크립트 작성 위치
```js
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JavaScript 코드의 작성 위치</title>
  <script>
    // 이곳에 주석처리하면
    //  1. 첫번째 위치 head태그 내에 script 태그를 생성하여, 태그안에 작성 가능
    document.write('자바스크립트 head 태그에 위치<br>');
  </script>
  <script src="./3. 01_js_location.js"></script>
</head>
<body>
  <!-- 여기에 내용을 작성하고 ctrl + / 를 하면 주석 처리가 된다. -->
  <script>
    // 2. body 태그 내에 script 태그를 생성하여 js코드 작성
    document.write('자바스크립트 body 태그에 위치 <br>');
    // 3. 01_js_location.js파일 생성
  </script>
  <script src="./3. 01_js_location.js"></script>
</body>
</html>
```

1. head 태그 내에 script 태그 생성 후 직접 js 코드 작성
2. body 태그 내에 script 태그 생성 후 직접 js 코드 작성
3. 별개의 .js 파일 생성 후 head / body 태그에 script src 부분에 .js 파일의 경로 삽입

- 참고 : 추가 확장 프로그램 Code runner 설치
  - .js에서 ctrl + alt + n 으로 실행가능
  - 문제점은 html 문서와 연동해서 읽는 것이 아니라 .js파일만 읽기 때문에 임시 방편이고, 미리 보기의 경우에는 개발자 도구를 확인할 수 없기 때문에 console.log를 확인할 수 없어서 
  - console과 document를 둘 다 사용하는 경우에는 live server를 활용하여 크롬 개발자 도구의 console과 문서 화면을 확인할 필요가 있다.

console이라는 객체의 .log 메서드가 어떤 역할을 하는지
document라고 하는 객체의 .write가 어떤 역할을 하는지 확인할 수 있었다.

## 변수와 상수
1. 변수(variable) : 데이터를 담는 그릇 / 바구니 / etc ... Js에서는 변수에 literal 뿐만이 아니라 객체도 담을 수 있다. _함수_도 담을 수 있다.
2. 상수(const) : 변화하지 않는 값을 가지고 있는 변수

### 변수 선언 형식
형식
선언자 변수명 = 데이터;
```js
var greeting = 'Hello World!';
console.log(greeting);
```

- Js 변수 선언 규칙
1. 변수명은 문자(특수 문자 제외), 숫자, _(언더스코어), $(달러 기호)를 포함하여 만들 수 있다.
2. 변수명은 숫자로 시작할 수 없다.
3. JS 예약어는 사용할 수 없다.(document를 변수명으로 짓지못함.)
4. 대소문자 구별
5. 스크립트 표준인 ECMA Script에서는 변수명 / 함수명은 카멜 케이스를 사용하고, 클래스명, 생성자명에는 파스칼 케이스를 사용할 것을 권장한다.

### var 선ㅇ너자 
JS 상에서는 데이터 타입(자료형)에 관계없이 변수를 저장할 때 var 선언자와 let 선언자를 사용할 수 있음.
실무에서는 주로 let을 사용한다. 그런데 부산에서는 var도 여전히 쓰는 것 같아 var부터 학습한다.

```js
var x = 5;
var y = 6;
var z = x + y; // 11이 저장된다.

// 이미 선언된 x변수에 다시 var 선언자를 쓸 수 있다.
var x = 7; 
// 이미 선언된 z 변수에 var 선언자를 쓰지않은 경우.
z = x+y; // 13이 저장된다.
```
JS는 동일한 변수명에 전혀 다른 기능을 넣어도(심지어 외부라이브러리의 변수명과 같아도) 오류가 발생하지않아 문제가 발생할 수 있다
이미 많은 웹사이트들이 var를 사용하여 코드를 작성했기때문에 var를 갑자기 금지 시키는 것은 불가능하다. 그래서 ES6부터는 let이라는 선언자를 도입해서 이를 권장한는 방식으로 개선이 이루어지고있다.

### let 선언자
ES6이후 추가된 선언자로, 기능은 동일하다. var의 문제점을 해결하기위해 등장했기 때문에 Java의 int/String/double을 대신해서 let을 쓴다고 생각하자.

1. 재대입을 할 때 또 let을 쓰면 오류 발생
2. 순서대로 실행되기 때문에
```js
console.log(a);
let a = 20;
console.log(a);
```
와 같은 방식으로 작성하면 오류발생

### const 선언자(상수)
마찬가지로 ES6에 추가된 선언자. 상수(constant)는 변화하지않는 변수를 의미한다.
Java를 수업할 때는 웬만하면 final을 쓰지않았던 것에 비해 Js에서는 웬만하면 const를 권장한다. 그럼 값이 안바뀌니까 웹 서비스 상에서의 유연성이 없지않냐는 의문이 있을 수 있으나 백엔드를 배우고 Js를 배우면 혼동이 오는 부분이다. 예시는 html과 섞어서 사용할때 들 예정

```js
const x = 3;
const y = 4;
const z = x + 7;
x=5; // 오류발생
```
const를 쓰는 경우는 애플리케이션 내에서 날짜를 보여주는 화면이 있다고 할 때 
1. 20250807
2. 2025-08-27
3. 2025/08/27
4. 2025.08.27
특정 페이지에서는 1번방식, 다른 페이지에서는 3번을 사용하진 않을 거고 동일한 웹서비스 내라면 하나의 양식으로 날짜를 출력할 것이다. 이상과 같은 경우 날짜 포맷 자체를 const로 선언한다.
```js
const DATE_FORMAT = 'yyyy-mm-dd';
```
DATE_FORMAT이 고정돼있으니 여기에 2025와 08과 27을 대입하는게 불가능하지않는가 하는 의문이 든다면 골치아파진다.

## 데이터 타입
### 기본 자료형
1. string
2. number(숫자 전체로 정수 실수를 가리지 않음)
3. boolean
4. undefined
5. null
6. symbol
#### string -> 넘어가겠다. js에서는 그냥 ''로 쓸 예정이다.
```js
console.log("제 이름은 '안근수'입니다.");
console.log('오늘 점심 뭐먹지? "짜장면"');

let name1 = "John Doe";
let name2 = "John Doe"; // 둘다 가능한데 ''를 쓸 예정. html과 헷갈리지 않도록

```

#### number -> int / short / long / double / float 다 퉁쳐서 number이다.

#### boolean -> 넘어가겠다.

#### undefined
  - 자료형이면서 동시에 데이터 값에 해당함. 정의되지않음. 을 의미하고, 변수를 선언하고 아무런 값을 할당하지 않으면 undefined가 자동 할당된다.

#### null
  - null도 undefined처럼 자료형이면서 데이터값에 해당하는데, 둘다 변수에 값이 없는 상태를 의미한다.
  차이점
    - undefined는 웹 브라이저 상에서 JS를 실행할 때, 값이 할당되지 않은 변수에 대해서 자도으로 undefined를 할당한다. 개발자가 아니라 브라우저 엔진이 할당하고 리턴해주는 것인 반면
    - null의 경우 개발자가 평가해서 사용한다. 선언된 변수에 대해서 아직 어떤 값을 할당할지 모르거나 어떤 데이터 타입이 할당될지 모르는 경우에 개발자가 명시적으로 null을 대입해두는 것을 의미한다.
    - 변수에 null을 할당하면 변수가 이전에 참조하던 값을 더이상 참조하지않기 때문에 메모리 효율성이 향상된다. java의 경우 가비지 컬렉터가 있기 때문에 참조되지않는 값은 알아서 제거되는 것처럼 JS도 일정 주기를 기준으로 메모리 공간을 확보하는데 이때 null을 확인하면 더이상 해당 변수에 대한 참조를 하지않는다.

#### symbol
  ES6에 추가된 새로운 자료형, 추후 설명

### 객체(Object)
추후 자세히 설명
자료형 개념으로서의 Object에 대해 설명한다.
JS의 모든것은 객체로 이루어져있다. 하지만 데이터 관점에서 사용하는 것은 Object와 Array이다.

#### object
object는 키(key)-값(value) 쌍으로 데이터를 저장한다.
```js
const person = {
  firstName = 'Jone',
  lastName = 'Doe',
  age: 20,
  eyeColor: 'blue'
};
```
앞부분인 key고 뒷부분이 value. JS상에서의 키-값 쌍을 property라고 한다.
- 수정 방법
```js
const person = {
  firstName: 'Jone',
  lastName: 'Doe',
  age: 20,
  eyeColor: 'blue'
};
// 객체의 출력
console.log(person);

//  객체의 property 수정방법 #1
person.firstName = '일'; // java에서의 field 수정법 유사
person.lastName = '김'; // access modifier 배우기 이전
console.log(person);

//  객체의 property 수정방법 #2
person['eyeColor'] = '검은색'; // java에서의 map 수정방법과 유사
console.log(person);
```

#### Array(배열)

하나 이상의 데이터를 하나의 변수명에 관리하기위한 방버브 이를 굳이 학술적으로 풀어쓰면 하나의 단일 참조(single reference)를 통해 다수 값을 확인 가능힌 구조. 배열에 저장된 데이터의 특징은 _순서_를 갖는가는 것이다.
console.log(객체) 출력값에서 properties에는 순서가 없다.

형식
```js
const cars = ['Hyundai', 'Kia', 'Ford', 'Nissan'];

```
java와의 차이점은 {}인가 []인가 이다.
나머지는 거의 동일
```js
console.log(cars[0]);
```
으로 출력가능
```js
cars[1] = 'Honda';
console.log(cars[1]); // Kia 아니고 Honda출력
```

#### typeof 연산자
java는 처음 변수 선언할 때 자료형을 미리 명시하기 때문에 필요없는 개념에 가깝긴한데, JS는 현재 변수에 어떤 자료형이 들어가 있는지 확인할 필요가 있다.

```js
let x = '안녕';
let y = 30;

// typeof 사용법
console.log(typeof x); // string
console.log(typeof y); // number

console.log(typeof {x:1, y:2}); // object
console.log(typeof [1,2,3]); // object
console.log(typeof null); // object
```
JS에서 배열도 object에 해당한다.

## 연산자(Operator)

### 할당 연산자 
  - 연산 결과를 = 왼쪽에 있는 변수에 대입할 때 사용하는 연산자들로,
    +, -, *, /, % 까지는 java와 동일
    js는 java와 달리 **가 있다.

    - ** : 지수 할당 연산자

```js
let x = 2;
let y = 3;
z = x ** y; // 2의 3제곱 2^3
console.log(z); // 8

```

#### 복합 연산자
+=, -=, *=, /=, %=, **=

```js
let x = 3;
let y = 2;
console.log(x%=y); // x = x%y; = 3 % 2

let a = 5;
let b = 2;
console.log(x**=y); // a = a ** b -> a = 5**2 = 5^2

```

#### 비교연산자
```js
let a = 3;
let b = '3';

console.log(a == b); // true
console.log(a === b); // false
```
JS에서는 서로 다른 자료형일 때도 비교한는 것이 가능한데 만약에 string == number를 비교하더라도 자료형을 제외하고 내부 데이터값만 비교해서 true를 도출한다.
== : a와 b의 값이 같은지를 비교함. 정확히는 string인 b를 number로 바꿔 비교하여 true return 
=== : a와 b의 값 뿐만 아니라 자료형까지 비교함.

!= : 서로 다른지 비교
!== : 자료형까지 확인하여 다른지 비교
`>`
`<`
`>=`
`<=`
#### 산술연산자
++ 
-- 
#### 논리연산자
and &&
or ||
! : 변수 앞에 !써서 true `<->` false로 서로 반전시킨다.
#### 문자열 연산자
+ 만 적용됨
#### 삼항연산자(JS에서 더 자주 쓴다.)
형식
```js
// 조건 ? 값1 : 값2;
let age = 18;
let isAdult = (age >= 20) ? true : false; // 조건이 true면 true return, 아니면 false return
// is로 시작하면 보통 boolean자료형

//  심화
//  조건1 ? 값1 : 조건2 ? 값 2 : 값3;
let point = 92;
let grade = (point >= 90) ? 'A' : (point >= 80) ? 'B' : 'C';
console.log(grade);
```
## 조건문 
1. if문(if / else if / else 포함해서 한꺼번에 하겠다.)
02_condition.html / 02_condition.js

2. switch문
03_condition_switch.html / 03_condition_switch.js 참조

## 반복문
반복문은 조건을 만족하는 동안 코드 블록을 반복적으로 수행한다. JS에서는 for / for-in / for-of / while과 같은 반복문을 지원한다.

04_loop.html / 04_loop.js

1. for-loop
  - 자바와 같다.
2. for-in 문
  - for-in문은 데이터 타입 중 배열 뿐만 아니라 객체에도 사용할 수 있는 반복문이다. index넘버를 사용하지 않고 key를 통해 읽는 방식이다.
  형식 :
  `for (const key in object명) { 실행문 };`
3. for-of 문

4. while 문
  - 일반 while문
  - do-while 문
```js
let j = 1;
do {
  console.log(j);
  j++;
} while(j <= 10);
```
자주 쓰진 않음

형식
```js
do {
  실행문;
} while(조건식);
```

## 함수(function) 
- 중요
### 정의
일반적으로 프로그래밍 언어에서 특정 작업을 여러 번 반복해야하는 경우, 해당 작업응 _재사용 가능한 구조_ 로 만드는 데, 이 때 사용하는 개념이 함수. 함수로 구현된 코드는 그 함수를 _호출_ 함으로써 반복된 기능을 쉽게 처리함.
JS는 특별한 경우를 제외하고 _기능에 따라_ 함수를 작성하며, 함수 안에 JS프로그램 코드를 구현함.
- 즉 , 특정한 기능을 수행하기 위한 일련의 코드 블록을 하나의 실행단위로 생성한 것.

### 함수 정의(선언) 및 사용

형식 
```js
Function 함수명(매개변수1, 매개변수2) {
  let 지역변수 = 데이터;
  return 결과값;
}
```

- 함수 선언 키워드 function
- 함수명
- 매개변수(optional)
- 실행문에 해당하는 코드블럭(함수 내에서 다른 함수를 호출하는 것도 가능)
- 결과값(optional)

예시
```js
Function sum(x, y) {
  let sum = x+y;
  return sum;
}
sum(10, 20); // 결과값이 30,
console.log(10, 20);
```
06_functions.html/js

### 함수 표현식
- _변수에 함수를 할당_해서 사용하는 방식
형식

```js
let 변수명 = function(매개변수1, 매개변수2) {
  let 지역변수 = 매개변수1, 매개변수2
  실행문
  return
}

// 함수 표현식 예시
let sum = function(x,y) {
  let result = x + y;
  return result;
}

// 원래 함수 선언 방식
function sum(x, y) {
  let sum = x+y;
  return sum;
}

sum(10, 20);
```

굳이 함수 표현식이라는 개념이 나온 이유 역시 var가 일으키는 문제와 유사하다.
기존의 함수 선언 방식과 선언자 var의 경우, js가 코드를 읽어들일 때, 일단 var / function으로 선언된 것을 미리 메모리에 올린다.
그 의미는 일단 먼저 변수/함수를 사용(호출)하고 나중에 선언/정의를 하더라도 문제가 없다는 것을 의미한다.

var의 문제처럼 function명 역시 동일하다면 더 밑에 정의된 함수가 덮어쓰기때문에 함수명이 겹치면 개발자가 원하는 결과값이 나오지 않는다.

이상을 이유로 function을 let으로 등록하면 코드가 순서대로 동작한다는 점에 착안하여 함수 표현식 개념이 등장했다.

hoisting 때문에 함수 표현식이 등장했고, 이를 통해 담보할 수 있는 것은 코드가 순서대로 실행된다는 점이다. 함수를 담고있는 변수에 대한 코드 구문이 함수를 호출하는 코드 구문보다 뒤에 있다면 오류가 발생한다.
```js
let sum1 = sum(21, 22); // 오류
let sum2 = sum(34, 15); // 오류

let sum = function(x, y) { // 함수 표현식
  return x+y;
}

```

### Function 생성자 함수
- JS 내장 함수인 Function 함수에 매개변수와 코드블럭을 _문자열_로 순서대로 전달하여 생성.

예시
```js
let sum = new function('x', 'y', 'return x+y');
let sum1 = sum(11, 22);
let sum2 = sum(22, 33);

```

07_calc.html / js